% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiple_replicates_chipr.R
\name{multiple_replicates_chipr}
\alias{multiple_replicates_chipr}
\title{Call peaks with MACSr and generate consensus set with ChIP-R}
\usage{
multiple_replicates_chipr(
  treat_files,
  control_files = NULL,
  is_paired = FALSE,
  out_dir = tempdir(),
  subdir_name = "chipr_analysis",
  minentries = 2,
  rankmethod = "pvalue",
  duphandling = "average",
  fragment = FALSE,
  seed = 0.5,
  alpha = 0.05,
  size = 20,
  ...
)
}
\arguments{
\item{treat_files}{Character vector containing paths to the treatment BAM
files.}

\item{control_files}{Character vector containing paths to the control BAM
files.}

\item{is_paired}{Logical, specifying whether or not the BAM file is
paired-end.}

\item{out_dir}{Character specifying the name of the output directory in which
a subdirectory containing the output files will be created.}

\item{subdir_name}{Character specifying the name of the subdirectory that the
output files will be written to.}

\item{minentries}{The minimum number of intersections a given peak must
satisfy.}

\item{rankmethod}{The ranking method used to rank peaks within
replicates. Options include "signalvalue", "pvalue" and "qvalue". The
default is "pvalue".}

\item{duphandling}{Method for breaking ties. The options are "average" or
"random". The default is "average".}

\item{fragment}{Logical specifying whether the input peaks should be subject
to high levels of fragmentation. The default is FALSE.}

\item{seed}{Numeric specifying a seed for when duphandling = "random".
Value must be between 0 and 1. The default is 0.5.}

\item{alpha}{Numeric cut-off value for deciding the set of reproducible
peaks. The default is 0.05.}

\item{size}{Numeric specifying the minimum peak size when peaks are
reconnected after fragmentation. The minimum peak size is ordinarily
determined by the size of surrounding peaks, but in the case that there are
none, this value will be used. The default is 20.}

\item{...}{
  Arguments passed on to \code{\link[MACSr:callpeak]{MACSr::callpeak}}
  \describe{
    \item{\code{gsize}}{Effective genome size. It can be 1.0e+9 or 1000000000,
or shortcuts:'hs' for human (2.7e9), 'mm' for mouse (1.87e9),
'ce' for C. elegans (9e7) and 'dm' for fruitfly (1.2e8),
Default:hs.}
    \item{\code{tsize}}{Tag size/read length. This will override the auto
detected tag size. DEFAULT: Not set}
    \item{\code{keepduplicates}}{It controls the behavior towards duplicate
tags at the exact same location -- the same coordination and
the same strand.}
    \item{\code{store_bdg}}{Whether or not to save extended fragment pileup,
and local lambda tracks (two files) at every bp into a bedGraph
file.}
    \item{\code{do_SPMR}}{If True, MACS will SAVE signal per million reads for
fragment pileup profiles.}
    \item{\code{trackline}}{Tells MACS to include trackline with bedGraph
files.}
    \item{\code{nomodel}}{Whether or not to build the shifting model.}
    \item{\code{shift}}{The arbitrary shift in bp. Use discretion while
setting it other than default value.}
    \item{\code{extsize}}{The arbitrary extension size in bp.}
    \item{\code{bw}}{Band width for picking regions to compute fragment size.}
    \item{\code{d_min}}{Minimum fragment size in basepair. Any predicted
fragment size less than this will be excluded.}
    \item{\code{mfold}}{Select the regions within MFOLD range of
high-confidence enrichment ratio against background to build
model.}
    \item{\code{onauto}}{Whether turn on the auto pair model process.}
    \item{\code{qvalue}}{Minimum FDR (q-value) cutoff for peak detection.}
    \item{\code{pvalue}}{Pvalue cutoff for peak detection. DEFAULT: not set.}
    \item{\code{tempdir}}{Optional directory to store temp files.}
    \item{\code{nolambda}}{If True, MACS will use fixed background lambda as
local lambda for every peak region.}
    \item{\code{scaleto}}{When set to 'small', scale the larger sample up to
the smaller sample.}
    \item{\code{downsample}}{When set, random sampling method will scale down
the bigger sample. By default, MACS uses linear scaling.}
    \item{\code{slocal}}{The small nearby region in basepairs to calculate
dynamic lambda.}
    \item{\code{llocal}}{The large nearby region in basepairs to calculate
dynamic lambda.}
    \item{\code{broad}}{If set, MACS will try to call broad peaks using the
--broad-cutoff setting.}
    \item{\code{broadcutoff}}{Cutoff for broad region. This option is not
available unless --broad is set.}
    \item{\code{maxgap}}{Maximum gap between significant sites to cluster them
together. The DEFAULT value is the detected read length/tag
size.}
    \item{\code{minlen}}{Minimum length of a peak. The DEFAULT value is the predicted
fragment size d.}
    \item{\code{cutoff_analysis}}{While set, MACS2 will analyze number or
total length of peaks that can be called by different p-value
cutoff then output a summary table to help user decide a better
cutoff.}
    \item{\code{fecutoff}}{When set, the value will be used to filter out
peaks with low fold-enrichment.}
    \item{\code{call_summits}}{If set, MACS will use a more sophisticated
signal processing approach to find subpeak summits in each
enriched peak region.}
    \item{\code{buffer_size}}{Buffer size for incrementally increasing
internal array size to store reads alignment
information. DEFAULT: 100000.}
    \item{\code{verbose}}{Set verbose level of runtime message. 0: only show
critical message, 1: show additional warning message, 2: show
process information, 3: show debug messages. DEFAULT:2}
  }}
}
\value{
A list containing a summary of the ChIP-r along with the path to the
output files.
}
\description{
\code{multiple_replicates_chipr()} is a wrapper of the Python package ChIP-R.
ChIP-R handles an arbitrary number of replicates.
}
\examples{
\dontrun{
input1 <- testthat::test_path("testdata", "r1_test_creb.bam")
input2 <- testthat::test_path("testdata", "r2_test_creb.bam")
input3 <- testthat::test_path("testdata", "r3_test_creb.bam")

multiple_replicates_chipr(treat_files = c(input1, input2, input3),
                          out_dir = tempdir(),
                          ...
                          )
                          }

}
