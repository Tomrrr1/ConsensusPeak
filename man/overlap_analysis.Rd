% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/overlapping_peaks.R
\name{overlap_analysis}
\alias{overlap_analysis}
\title{Call consensus peaks based on overlap across replicates}
\usage{
overlap_analysis(
  treat_files,
  control_files = NULL,
  is_paired,
  maxgap = 0L,
  minoverlap = 0.5,
  connectedPeaks = "merge",
  out_dir,
  subdir_name = "overlap_analysis",
  ...
)
}
\arguments{
\item{treat_files}{Character vector containing paths to the treatment BAM
files.}

\item{control_files}{Character vector containing paths to the control BAM
files. The default is NULL}

\item{is_paired}{Logical, specifying whether or not the BAM files are
paired-end. The default is FALSE.}

\item{maxgap, minoverlap}{Used in the internal call to \code{findOverlaps()}
to detect overlaps. See
\code{?\link[IRanges:findOverlaps-methods]{findOverlaps}} in the
\pkg{IRanges} package for a description of these arguments. 
If 0 < minoverlap < 1, the function will find overlaps by percentage
covered of interval and the filter condition will be set to max covered 
percentage of overlapping peaks.}

\item{connectedPeaks}{If multiple peaks are involved in any group of 
connected/overlapping peaks in any input peak list, set it to "merge" will
add 1 to the overlapping counts, while set it to "min" will add the minimal 
involved peaks in each group of connected/overlapped peaks to the 
overlapping counts. Set it to "keepAll" will add the number of involved 
peaks for each peak list to the corresponding overlapping counts. 
In addition, it will output counts as if connectedPeaks were set to "min".
For examples (https://support.bioconductor.org/p/133486/#133603), 
if 5 peaks in group1 overlap with 2 peaks in group 2, setting connectedPeaks
 to "merge" will add 1 to the overlapping counts; setting it to "keepAll" 
 will add 5 peaks to count.group1, 2 to count.group2, and 2 to counts; 
 setting it to “min” will add 2 to the overlapping counts.}

\item{out_dir}{Character specifying the path at which the results directory
will be created. By default, the results directories are created in
tempdir().}

\item{...}{
  Arguments passed on to \code{\link[MACSr:callpeak]{MACSr::callpeak}}
  \describe{
    \item{\code{gsize}}{Effective genome size. It can be 1.0e+9 or 1000000000,
or shortcuts:'hs' for human (2.7e9), 'mm' for mouse (1.87e9),
'ce' for C. elegans (9e7) and 'dm' for fruitfly (1.2e8),
Default:hs.}
    \item{\code{tsize}}{Tag size/read length. This will override the auto
detected tag size. DEFAULT: Not set}
    \item{\code{keepduplicates}}{It controls the behavior towards duplicate
tags at the exact same location -- the same coordination and
the same strand.}
    \item{\code{store_bdg}}{Whether or not to save extended fragment pileup,
and local lambda tracks (two files) at every bp into a bedGraph
file.}
    \item{\code{do_SPMR}}{If True, MACS will SAVE signal per million reads for
fragment pileup profiles.}
    \item{\code{trackline}}{Tells MACS to include trackline with bedGraph
files.}
    \item{\code{nomodel}}{Whether or not to build the shifting model.}
    \item{\code{shift}}{The arbitrary shift in bp. Use discretion while
setting it other than default value.}
    \item{\code{extsize}}{The arbitrary extension size in bp.}
    \item{\code{bw}}{Band width for picking regions to compute fragment size.}
    \item{\code{d_min}}{Minimum fragment size in basepair. Any predicted
fragment size less than this will be excluded.}
    \item{\code{mfold}}{Select the regions within MFOLD range of
high-confidence enrichment ratio against background to build
model.}
    \item{\code{onauto}}{Whether turn on the auto pair model process.}
    \item{\code{qvalue}}{Minimum FDR (q-value) cutoff for peak detection.}
    \item{\code{pvalue}}{Pvalue cutoff for peak detection. DEFAULT: not set.}
    \item{\code{tempdir}}{Optional directory to store temp files.}
    \item{\code{nolambda}}{If True, MACS will use fixed background lambda as
local lambda for every peak region.}
    \item{\code{scaleto}}{When set to 'small', scale the larger sample up to
the smaller sample.}
    \item{\code{downsample}}{When set, random sampling method will scale down
the bigger sample. By default, MACS uses linear scaling.}
    \item{\code{slocal}}{The small nearby region in basepairs to calculate
dynamic lambda.}
    \item{\code{llocal}}{The large nearby region in basepairs to calculate
dynamic lambda.}
    \item{\code{broad}}{If set, MACS will try to call broad peaks using the
--broad-cutoff setting.}
    \item{\code{broadcutoff}}{Cutoff for broad region. This option is not
available unless --broad is set.}
    \item{\code{minlen}}{Minimum length of a peak. The DEFAULT value is the predicted
fragment size d.}
    \item{\code{cutoff_analysis}}{While set, MACS2 will analyze number or
total length of peaks that can be called by different p-value
cutoff then output a summary table to help user decide a better
cutoff.}
    \item{\code{fecutoff}}{When set, the value will be used to filter out
peaks with low fold-enrichment.}
    \item{\code{call_summits}}{If set, MACS will use a more sophisticated
signal processing approach to find subpeak summits in each
enriched peak region.}
    \item{\code{buffer_size}}{Buffer size for incrementally increasing
internal array size to store reads alignment
information. DEFAULT: 100000.}
    \item{\code{verbose}}{Set verbose level of runtime message. 0: only show
critical message, 1: show additional warning message, 2: show
process information, 3: show debug messages. DEFAULT:2}
  }}
}
\value{
A list containing the path to the output consensus peak file and a
Venn diagram illustrating overlap across replicates.
}
\description{
\code{overlap analysis()} calls consensus peaks by taking overlapping peak
calls across replicates. The sensitivity can be altered by varying the
\code{minoverlap} parameter.
}
\examples{
\dontrun{
input1 <- testthat::test_path("testdata", "r1_test_creb.bam")
input2 <- testthat::test_path("testdata", "r2_test_creb.bam")
input3 <- testthat::test_path("testdata", "r3_test_creb.bam")

results <- overlap_analysis(
  treat_files = c(input1, input2, input3),
  control_files = NULL,
  is_paired = FALSE,
  maxgap = 0L,
  minoverlap = 0.5,
  connectedPeaks = "merge",
  out_dir = tempdir(),
  subdir_name = "overlap_analysis"
  nomodel = TRUE,
  qvalue = 0.01
  )
  }

}
